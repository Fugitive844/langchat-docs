import{_ as i,c as a,o as t,ag as d}from"./chunks/framework.ByciF0Oj.js";const p=JSON.parse('{"title":"RAG API 基础","description":"","frontmatter":{"title":"RAG API 基础"},"headers":[],"relativePath":"course/docs/15RAGAPI.md","filePath":"course/docs/15RAGAPI.md","lastUpdated":1738637454000}'),o={name:"course/docs/15RAGAPI.md"};function l(n,e,s,c,r,h){return t(),a("div",null,e[0]||(e[0]=[d(`<p>LangChain4j 是一个强大的 Java 库,提供了丰富的 API 来简化构建自定义 RAG(检索增强生成)管道的过程。本指南将详细介绍 LangChain4j 的主要组件和 API,从简单到复杂的多种管道实现。</p><img src="https://minio.pigx.top/oss/202410/1728455030.png" alt="1728455030"><h2 id="_2-核心概念" tabindex="-1">2. 核心概念 <a class="header-anchor" href="#_2-核心概念" aria-label="Permalink to &quot;2. 核心概念&quot;">​</a></h2><h3 id="_2-1-document-文档" tabindex="-1">2.1 Document (文档) <a class="header-anchor" href="#_2-1-document-文档" aria-label="Permalink to &quot;2.1 Document (文档)&quot;">​</a></h3><p><code>Document</code> 类表示一个完整的文档,例如单个 PDF 文件或网页。</p><h4 id="主要方法" tabindex="-1">主要方法: <a class="header-anchor" href="#主要方法" aria-label="Permalink to &quot;主要方法:&quot;">​</a></h4><ul><li><code>Document.text()</code>: 返回文档的文本内容</li><li><code>Document.metadata()</code>: 返回文档的元数据</li><li><code>Document.toTextSegment()</code>: 将 <code>Document</code> 转换为 <code>TextSegment</code></li><li><code>Document.from(String, Metadata)</code>: 从文本和元数据创建 <code>Document</code></li><li><code>Document.from(String)</code>: 从文本创建不带元数据的 <code>Document</code></li></ul><h3 id="_2-2-metadata-元数据" tabindex="-1">2.2 Metadata (元数据) <a class="header-anchor" href="#_2-2-metadata-元数据" aria-label="Permalink to &quot;2.2 Metadata (元数据)&quot;">​</a></h3><p><code>Metadata</code> 存储文档的额外信息,如名称、来源、最后更新时间等。</p><h4 id="主要方法-1" tabindex="-1">主要方法: <a class="header-anchor" href="#主要方法-1" aria-label="Permalink to &quot;主要方法:&quot;">​</a></h4><ul><li><code>Metadata.from(Map)</code>: 从 <code>Map</code> 创建 <code>Metadata</code></li><li><code>Metadata.put(String key, String value)</code>: 添加元数据条目</li><li><code>Metadata.getString(String key)</code> / <code>getInteger(String key)</code>: 获取指定类型的元数据值</li><li><code>Metadata.containsKey(String key)</code>: 检查是否包含指定键</li><li><code>Metadata.remove(String key)</code>: 移除指定键的元数据条目</li><li><code>Metadata.copy()</code>: 复制元数据</li><li><code>Metadata.toMap()</code>: 将元数据转换为 <code>Map</code></li></ul><h3 id="_2-3-textsegment-文本片段" tabindex="-1">2.3 TextSegment (文本片段) <a class="header-anchor" href="#_2-3-textsegment-文本片段" aria-label="Permalink to &quot;2.3 TextSegment (文本片段)&quot;">​</a></h3><p><code>TextSegment</code> 表示文档的一个片段,专用于文本信息。</p><h4 id="主要方法-2" tabindex="-1">主要方法: <a class="header-anchor" href="#主要方法-2" aria-label="Permalink to &quot;主要方法:&quot;">​</a></h4><ul><li><code>TextSegment.text()</code>: 返回文本片段的内容</li><li><code>TextSegment.metadata()</code>: 返回文本片段的元数据</li><li><code>TextSegment.from(String, Metadata)</code>: 从文本和元数据创建 <code>TextSegment</code></li><li><code>TextSegment.from(String)</code>: 从文本创建不带元数据的 <code>TextSegment</code></li></ul><h3 id="_2-4-embedding-嵌入" tabindex="-1">2.4 Embedding (嵌入) <a class="header-anchor" href="#_2-4-embedding-嵌入" aria-label="Permalink to &quot;2.4 Embedding (嵌入)&quot;">​</a></h3><p><code>Embedding</code> 类封装了一个数值向量,表示嵌入内容的语义含义。</p><h4 id="主要方法-3" tabindex="-1">主要方法: <a class="header-anchor" href="#主要方法-3" aria-label="Permalink to &quot;主要方法:&quot;">​</a></h4><ul><li><code>Embedding.dimension()</code>: 返回嵌入向量的维度</li><li><code>CosineSimilarity.between(Embedding, Embedding)</code>: 计算两个嵌入向量的余弦相似度</li><li><code>Embedding.normalize()</code>: 对嵌入向量进行归一化</li></ul><h2 id="_3-文档处理" tabindex="-1">3. 文档处理 <a class="header-anchor" href="#_3-文档处理" aria-label="Permalink to &quot;3. 文档处理&quot;">​</a></h2><h3 id="_3-1-document-loader-文档加载器" tabindex="-1">3.1 Document Loader (文档加载器) <a class="header-anchor" href="#_3-1-document-loader-文档加载器" aria-label="Permalink to &quot;3.1 Document Loader (文档加载器)&quot;">​</a></h3><p>LangChain4j 提供了多种文档加载器:</p><ul><li><code>FileSystemDocumentLoader</code>: 从文件系统加载文档</li><li><code>UrlDocumentLoader</code>: 从 URL 加载文档</li><li><code>AmazonS3DocumentLoader</code>: 从 Amazon S3 加载文档</li><li><code>AzureBlobStorageDocumentLoader</code>: 从 Azure Blob 存储加载文档</li><li><code>GitHubDocumentLoader</code>: 从 GitHub 仓库加载文档</li><li><code>TencentCosDocumentLoader</code>: 从腾讯云 COS 加载文档</li></ul><h3 id="_3-2-document-parser-文档解析器" tabindex="-1">3.2 Document Parser (文档解析器) <a class="header-anchor" href="#_3-2-document-parser-文档解析器" aria-label="Permalink to &quot;3.2 Document Parser (文档解析器)&quot;">​</a></h3><p>用于解析不同格式的文档:</p><ul><li><code>TextDocumentParser</code>: 解析纯文本文件</li><li><code>ApachePdfBoxDocumentParser</code>: 解析 PDF 文件</li><li><code>ApachePoiDocumentParser</code>: 解析 MS Office 文件格式</li><li><code>ApacheTikaDocumentParser</code>: 自动检测并解析几乎所有文件格式</li></ul><p>示例:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载单个文档</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Document document </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FileSystemDocumentLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadDocument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/file.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TextDocumentParser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载目录下的所有文档</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Document</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; documents </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FileSystemDocumentLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadDocuments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/directory&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TextDocumentParser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><h3 id="_3-3-document-transformer-文档转换器" tabindex="-1">3.3 Document Transformer (文档转换器) <a class="header-anchor" href="#_3-3-document-transformer-文档转换器" aria-label="Permalink to &quot;3.3 Document Transformer (文档转换器)&quot;">​</a></h3><p><code>DocumentTransformer</code> 用于对文档执行各种转换,如清理、过滤、增强或总结。</p><p>目前提供的转换器:</p><ul><li><code>HtmlToTextDocumentTransformer</code>: 从 HTML 中提取文本内容和元数据</li></ul><h3 id="_3-4-document-splitter-文档拆分器" tabindex="-1">3.4 Document Splitter (文档拆分器) <a class="header-anchor" href="#_3-4-document-splitter-文档拆分器" aria-label="Permalink to &quot;3.4 Document Splitter (文档拆分器)&quot;">​</a></h3><p>用于将文档拆分成更小的片段:</p><ul><li><code>DocumentByParagraphSplitter</code>: 按段落拆分</li><li><code>DocumentBySentenceSplitter</code>: 按句子拆分</li><li><code>DocumentByWordSplitter</code>: 按单词拆分</li><li><code>DocumentByCharacterSplitter</code>: 按字符拆分</li><li><code>DocumentByRegexSplitter</code>: 按正则表达式拆分</li></ul><p>使用步骤:</p><ol><li>实例化 <code>DocumentSplitter</code> 并指定 <code>TextSegment</code> 的大小和重叠字符数</li><li>调用 <code>split(Document)</code> 或 <code>splitAll(List&lt;Document&gt;)</code> 方法</li><li><code>DocumentSplitter</code> 将文档拆分成小片段,并组合为 <code>TextSegment</code></li></ol><h2 id="_4-嵌入处理" tabindex="-1">4. 嵌入处理 <a class="header-anchor" href="#_4-嵌入处理" aria-label="Permalink to &quot;4. 嵌入处理&quot;">​</a></h2><h3 id="_4-1-embedding-model-嵌入模型" tabindex="-1">4.1 Embedding Model (嵌入模型) <a class="header-anchor" href="#_4-1-embedding-model-嵌入模型" aria-label="Permalink to &quot;4.1 Embedding Model (嵌入模型)&quot;">​</a></h3><p><code>EmbeddingModel</code> 接口表示一种将文本转换为 <code>Embedding</code> 的模型。</p><h4 id="主要方法-4" tabindex="-1">主要方法: <a class="header-anchor" href="#主要方法-4" aria-label="Permalink to &quot;主要方法:&quot;">​</a></h4><ul><li><code>EmbeddingModel.embed(String)</code>: 嵌入指定文本</li><li><code>EmbeddingModel.embed(TextSegment)</code>: 嵌入指定 <code>TextSegment</code></li><li><code>EmbeddingModel.embedAll(List&lt;TextSegment&gt;)</code>: 嵌入多个 <code>TextSegment</code></li><li><code>EmbeddingModel.dimension()</code>: 返回嵌入向量的维度</li></ul><h3 id="_4-2-embedding-store-嵌入存储" tabindex="-1">4.2 Embedding Store (嵌入存储) <a class="header-anchor" href="#_4-2-embedding-store-嵌入存储" aria-label="Permalink to &quot;4.2 Embedding Store (嵌入存储)&quot;">​</a></h3><p><code>EmbeddingStore</code> 接口表示一个嵌入存储库(向量数据库),用于存储和高效搜索相似的嵌入。</p><h4 id="主要方法-5" tabindex="-1">主要方法: <a class="header-anchor" href="#主要方法-5" aria-label="Permalink to &quot;主要方法:&quot;">​</a></h4><ul><li><code>EmbeddingStore.add(Embedding)</code>: 添加嵌入并返回随机 ID</li><li><code>EmbeddingStore.addAll(List&lt;Embedding&gt;)</code>: 添加多个嵌入并返回随机 ID 列表</li><li><code>EmbeddingStore.search(EmbeddingSearchRequest)</code>: 搜索最相似的嵌入</li><li><code>EmbeddingStore.remove(String id)</code>: 删除指定 ID 的嵌入</li></ul><h3 id="_4-3-embedding-store-ingestor-嵌入存储摄取器" tabindex="-1">4.3 Embedding Store Ingestor (嵌入存储摄取器) <a class="header-anchor" href="#_4-3-embedding-store-ingestor-嵌入存储摄取器" aria-label="Permalink to &quot;4.3 Embedding Store Ingestor (嵌入存储摄取器)&quot;">​</a></h3><p><code>EmbeddingStoreIngestor</code> 负责将文档嵌入并存储到 <code>EmbeddingStore</code> 中。</p><p>示例:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EmbeddingStoreIngestor ingestor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EmbeddingStoreIngestor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">embeddingModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(embeddingModel)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">embeddingStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(embeddingStore)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ingestor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ingest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document1);</span></span></code></pre></div><p>可以通过指定 <code>DocumentTransformer</code> 和 <code>DocumentSplitter</code>,在嵌入前对文档进行转换和拆分。</p><h2 id="_5-构建-rag-管道" tabindex="-1">5. 构建 RAG 管道 <a class="header-anchor" href="#_5-构建-rag-管道" aria-label="Permalink to &quot;5. 构建 RAG 管道&quot;">​</a></h2><p>使用 LangChain4j 构建 RAG 管道的一般步骤:</p><ol><li>加载文档: 使用适当的 <code>DocumentLoader</code> 和 <code>DocumentParser</code> 加载文档</li><li>转换文档: 使用 <code>DocumentTransformer</code> 清理或增强文档(可选)</li><li>拆分文档: 使用 <code>DocumentSplitter</code> 将文档拆分为更小的片段</li><li>嵌入文档: 使用 <code>EmbeddingModel</code> 将文档片段转换为嵌入向量</li><li>存储嵌入: 使用 <code>EmbeddingStore</code> 存储嵌入向量</li><li>检索相关内容: 根据用户查询,从 <code>EmbeddingStore</code> 检索最相关的文档片段</li><li>生成响应: 将检索到的相关内容与用户查询一起提供给语言模型,生成最终响应</li></ol><h2 id="_6-最佳实践" tabindex="-1">6. 最佳实践 <a class="header-anchor" href="#_6-最佳实践" aria-label="Permalink to &quot;6. 最佳实践&quot;">​</a></h2><ul><li>根据具体需求选择合适的文档拆分策略</li><li>使用自定义的 <code>DocumentTransformer</code> 来清理和增强文档</li><li>选择合适的嵌入模型和嵌入存储以平衡性能和准确性</li><li>定期更新和维护嵌入存储,以确保信息的时效性</li><li>对检索结果进行后处理,如重新排序或过滤,以提高相关性</li></ul><h2 id="_7-结语" tabindex="-1">7. 结语 <a class="header-anchor" href="#_7-结语" aria-label="Permalink to &quot;7. 结语&quot;">​</a></h2><p>LangChain4j 提供了构建高效 RAG 系统所需的全套工具。通过灵活组合这些组件,您可以创建适合特定用例的自定义 RAG 管道。随着项目的发展,不断优化和调整各个组件,以提高系统的整体性能和准确性。</p>`,58)]))}const u=i(o,[["render",l]]);export{p as __pageData,u as default};
