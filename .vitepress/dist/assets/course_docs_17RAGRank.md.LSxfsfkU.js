import{_ as s,c as a,o as n,ag as l}from"./chunks/framework.ByciF0Oj.js";const g=JSON.parse('{"title":"RAG 结果重排","description":"","frontmatter":{"title":"RAG 结果重排"},"headers":[],"relativePath":"course/docs/17RAGRank.md","filePath":"course/docs/17RAGRank.md","lastUpdated":1738637454000}'),t={name:"course/docs/17RAGRank.md"};function e(h,i,r,p,k,d){return n(),a("div",null,i[0]||(i[0]=[l(`<img src="https://minio.pigx.top/oss/202410/1728463069.png" alt="1728463069"><h2 id="rrf" tabindex="-1">RRF <a class="header-anchor" href="#rrf" aria-label="Permalink to &quot;RRF&quot;">​</a></h2><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><p>Reciprocal Rank Fusion (RRF) 是一种用于结合多个排序结果的简单而有效的算法。它通过计算每个候选项在多个列表中的排名倒数，然后将这些倒数相加，从而得出一个“融合分数”，并根据该分数对候选项进行重新排序。</p><h3 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h3><p>假设你和三个朋友在寻找一本丢失的书，每个人列出了最有可能找到书的地点，并按从高到低的顺序进行排序。RRF 就是结合这些排序结果，帮助找到最有可能的地点。</p><h4 id="列表数据" tabindex="-1">列表数据 <a class="header-anchor" href="#列表数据" aria-label="Permalink to &quot;列表数据&quot;">​</a></h4><ul><li><p><strong>朋友A的列表：</strong></p><ol><li>书架</li><li>桌子</li><li>床下</li></ol></li><li><p><strong>朋友B的列表：</strong></p><ol><li>床下</li><li>书架</li><li>桌子</li></ol></li><li><p><strong>朋友C的列表：</strong></p><ol><li>桌子</li><li>书架</li><li>床下</li></ol></li></ul><h4 id="rrf-计算过程" tabindex="-1">RRF 计算过程 <a class="header-anchor" href="#rrf-计算过程" aria-label="Permalink to &quot;RRF 计算过程&quot;">​</a></h4><p>我们为每个地点计算在每个列表中的排名倒数，然后将这些倒数相加，得到融合分数。</p><ol><li><p><strong>书架</strong></p><ul><li>在朋友A的列表中排名第1：$ \\frac{1}{1} = 1$</li><li>在朋友B的列表中排名第2：$ \\frac{1}{2} = 0.5$</li><li>在朋友C的列表中排名第2：$ \\frac{1}{2} = 0.5$</li><li><strong>总分：</strong> $1 + 0.5 + 0.5 = 2$</li></ul></li><li><p><strong>床下</strong></p><ul><li>在朋友A的列表中排名第3：$ \\frac{1}{3} = 0.33$</li><li>在朋友B的列表中排名第1：$ \\frac{1}{1} = 1$</li><li>在朋友C的列表中排名第3：$ \\frac{1}{3} = 0.33$</li><li><strong>总分：</strong> $0.33 + 1 + 0.33 = 1.66$</li></ul></li><li><p><strong>桌子</strong></p><ul><li>在朋友A的列表中排名第2：$ \\frac{1}{2} = 0.5$</li><li>在朋友B的列表中排名第3：$ \\frac{1}{3} = 0.33$</li><li>在朋友C的列表中排名第1：$ \\frac{1}{1} = 1$</li><li><strong>总分：</strong> $0.5 + 0.33 + 1 = 1.83$</li></ul></li></ol><h4 id="排序结果" tabindex="-1">排序结果 <a class="header-anchor" href="#排序结果" aria-label="Permalink to &quot;排序结果&quot;">​</a></h4><p>最后，我们根据每个地点的融合分数排序：</p><ul><li><strong>书架</strong>: 2</li><li><strong>桌子</strong>: 1.83</li><li><strong>床下</strong>: 1.66</li></ul><p>因此，书架是最有可能找到书的地点。</p><p>这个例子清楚地展示了RRF如何结合多个列表进行排序，从而提高结果的精确性。这种方法常用于信息检索和文档重排序中。</p><h3 id="reranker" tabindex="-1">Reranker <a class="header-anchor" href="#reranker" aria-label="Permalink to &quot;Reranker&quot;">​</a></h3><p>重排序模型的核心是计算用户查询与候选文档之间的语义匹配度，并根据该匹配度对结果进行重新排序。通过这种方式，语义排序的效果能够得到显著提升。它的原理是对每个候选文档计算与用户查询的相关性分数，并按相关性高低输出排序后的文档列表。</p><p><img src="https://minio.pigx.top/oss/202410/1728447436.png" alt="RAG Reranking Process" loading="lazy"></p><p>Jina AI提供了一个强大的reranker模型，可以轻松集成到LangChain4j项目中。以下是使用Jina Reranker的基本步骤。</p><h4 id="maven-依赖" tabindex="-1">Maven 依赖 <a class="header-anchor" href="#maven-依赖" aria-label="Permalink to &quot;Maven 依赖&quot;">​</a></h4><p>在你的Maven项目中添加以下依赖：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;dev.langchain4j&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;langchain4j-jina&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-label="Permalink to &quot;基本用法&quot;">​</a></h4><p>以下是在LangChain4j中使用Jina Reranker的基本示例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建Jina评分模型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ScoringModel scoringModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JinaScoringModel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apiKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getenv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;JINA_API_KEY&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">modelName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jina-reranker-v2-base-multilingual&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建内容聚合器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ContentAggregator contentAggregator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReRankingContentAggregator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scoringModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scoringModel)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 可以添加其他配置选项</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建检索增强器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RetrievalAugmentor retrievalAugmentor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DefaultRetrievalAugmentor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 添加其他必要的配置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contentAggregator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contentAggregator)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构建AI服务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Assistant assistant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AiServices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Assistant.class)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chatLanguageModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 配置你的语言模型 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">retrievalAugmentor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(retrievalAugmentor)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h4 id="关键组件说明" tabindex="-1">关键组件说明 <a class="header-anchor" href="#关键组件说明" aria-label="Permalink to &quot;关键组件说明&quot;">​</a></h4><ol><li><strong>JinaScoringModel</strong>: Jina Reranker的核心组件，需要API密钥和模型名称。</li><li><strong>ReRankingContentAggregator</strong>: 使用评分模型来重新排序检索到的内容。</li><li><strong>RetrievalAugmentor</strong>: 整合检索和重新排序过程的高级组件。</li><li><strong>AiServices</strong>: LangChain4j的工具类，用于构建集成了各种功能的AI服务。</li></ol><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li>设置<code>JINA_API_KEY</code>环境变量。</li><li>选择适合任务的Jina模型。</li><li>ReRankingContentAggregator和RetrievalAugmentor可能需要额外配置。</li></ul><h4 id="进阶使用" tabindex="-1">进阶使用 <a class="header-anchor" href="#进阶使用" aria-label="Permalink to &quot;进阶使用&quot;">​</a></h4><ol><li>调整重新排序的参数，如考虑的结果数量。</li><li>结合其他检索技术，如向量搜索。</li><li>实现自定义的评分逻辑。</li></ol><h2 id="rrf-vs-reranker-比较" tabindex="-1">RRF vs Reranker 比较 <a class="header-anchor" href="#rrf-vs-reranker-比较" aria-label="Permalink to &quot;RRF vs Reranker 比较&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特点</th><th>Reciprocal Rank Fusion (RRF)</th><th>重排序 (Rerank)</th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>融合来自多个源的结果</td><td>对初步结果进行重新排序</td></tr><tr><td><strong>方法</strong></td><td>计算排名倒数并累加</td><td>使用模型评估相关性并调整顺序</td></tr><tr><td><strong>实现复杂度</strong></td><td>相对简单</td><td>依赖特定模型，复杂度较高</td></tr><tr><td><strong>适用场景</strong></td><td>多源数据融合</td><td>结果优化和精细化处理</td></tr></tbody></table><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><p>RRF和Reranker是两种不同但互补的技术。RRF更适合于多源数据的融合，而Reranker则专注于提高单一查询结果集的质量和相关性。在实际应用中，可以根据具体需求选择适当的方法，或将两者结合使用以达到更好的信息检索效果。通过集成像Jina Reranker这样的工具到LangChain4j项目中，可以显著提高检索结果的质量，这对于构建高性能的问答系统、搜索引擎或任何需要精确信息检索的应用程序都是非常有价值的。</p>`,36)]))}const E=s(t,[["render",e]]);export{g as __pageData,E as default};
